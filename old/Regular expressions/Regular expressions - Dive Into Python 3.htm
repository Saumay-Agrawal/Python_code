<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta charset="utf-8">
<title>Regular expressions - Dive Into Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel="stylesheet" href="Regular%20expressions%20-%20Dive%20Into%20Python%203_files/dip3.css">
<style>
body{counter-reset:h1 5}
</style>
<link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="Regular%20expressions%20-%20Dive%20Into%20Python%203_files/mobile.css">
<link rel="stylesheet" media="print" href="Regular%20expressions%20-%20Dive%20Into%20Python%203_files/print.css">
<meta name="viewport" content="initial-scale=1.0">
</head><body><form action="http://www.google.com/cse"><div><input name="cx" value="014021643941856155761:l5eihuescdw" type="hidden"><input name="ie" value="UTF-8" type="hidden">&nbsp;<input name="q" size="25" placeholder="powered by Google™" type="search">&nbsp;<input name="root" value="Search" type="submit"></div></form>
<p>You are here: <a href="http://www.diveintopython3.net/index.html">Home</a> <span class="u">‣</span> <a href="http://www.diveintopython3.net/table-of-contents.html#regular-expressions">Dive Into Python 3</a> <span class="u">‣</span>
</p><p id="level">Difficulty level: <span class="u" title="intermediate">♦♦♦♢♢</span>
</p><h1>Regular Expressions</h1>
<blockquote class="q">
<p><span class="u">❝</span> Some people, when confronted with a problem, think “I know, I’ll use regular expressions.”  Now they have two problems. <span class="u">❞</span><br>— <a href="http://www.jwz.org/hacks/marginal.html">Jamie Zawinski</a>
</p></blockquote>
<p id="toc"><span class="nm u">‣</span> <a href="javascript:showTOC()">show table of contents</a></p><h2 id="divingin">Diving In<a href="#divingin" class="hl">#</a></h2>
<p class="f">Getting a small bit of text out of a large block of text is
 a challenge. In Python, strings have methods for searching and 
replacing: <code>index()</code>, <code>find()</code>, <code>split()</code>, <code>count()</code>, <code>replace()</code>, <i class="baa">&amp;</i>c. But these methods are limited to the simplest of cases. For example, the <code>index()</code>
 method looks for a single, hard-coded substring, and the search is 
always case-sensitive. To do case-insensitive searches of a string <var>s</var>, you must call <code>s.lower()</code> or <code>s.upper()</code> and make sure your search strings are the appropriate case to match. The <code>replace()</code> and <code>split()</code> methods have the same limitations.
</p><p>If your goal can be accomplished with string methods, you should 
use them. They’re fast and simple and easy to read, and there’s a lot to
 be said for fast, simple, readable code. But if you find yourself using
 a lot of different string functions with <code>if</code> statements to handle special cases, or if you’re chaining calls to <code>split()</code> and <code>join()</code> to slice-and-dice your strings, you may need to move up to regular expressions.
</p><p>Regular expressions are a powerful and (mostly) standardized way 
of searching, replacing, and parsing text with complex patterns of 
characters. Although the regular expression syntax is tight and unlike 
normal code, the result can end up being <em>more</em> readable than a 
hand-rolled solution that uses a long chain of string functions. There 
are even ways of embedding comments within regular expressions, so you 
can include fine-grained documentation within them.
</p><blockquote class="note compare perl5">
<p><span class="u">☞</span>If you’ve used regular expressions in other 
languages (like Perl, JavaScript, or PHP), Python’s syntax will be very 
familiar. Read the summary of the <a href="http://docs.python.org/dev/library/re.html#module-contents"><code>re</code> module</a> to get an overview of the available functions and their arguments.
</p></blockquote>
<p class="a">⁂

</p><h2 id="streetaddresses">Case Study: Street Addresses<a href="#streetaddresses" class="hl">#</a></h2>
<p>This series of examples was inspired by a real-life problem I had in 
my day job several years ago, when I needed to scrub and standardize 
street addresses exported from a legacy system before importing them 
into a newer system. (See, I don’t just make this stuff up; it’s 
actually useful.)  This example shows how I approached the problem.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre0">skip over this code listing</a></p><pre id="autopre0" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre0')">hide</a>] [<a href="javascript:plainTextOnClick('autopre0')">open in new window</a>]</div><div class="b"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">s </span><span class="pun">=</span><span class="pln"> </span><span class="str">'100 NORTH MAIN ROAD'</span></kbd>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">s</span><span class="pun">.</span><span class="pln">replace</span><span class="pun">(</span><span class="str">'ROAD'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'RD.'</span><span class="pun">)</span></kbd>                <span class="u">①</span></a>
<samp class="pp"><span class="str">'100 NORTH MAIN RD.'</span></samp>
<samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">s </span><span class="pun">=</span><span class="pln"> </span><span class="str">'100 NORTH BROAD ROAD'</span></kbd>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">s</span><span class="pun">.</span><span class="pln">replace</span><span class="pun">(</span><span class="str">'ROAD'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'RD.'</span><span class="pun">)</span></kbd>                <span class="u">②</span></a>
<samp class="pp"><span class="str">'100 NORTH BRD. RD.'</span></samp>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">s</span><span class="pun">[:-</span><span class="lit">4</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> s</span><span class="pun">[-</span><span class="lit">4</span><span class="pun">:].</span><span class="pln">replace</span><span class="pun">(</span><span class="str">'ROAD'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'RD.'</span><span class="pun">)</span></kbd>  <span class="u">③</span></a>
<samp class="pp"><span class="str">'100 NORTH BROAD RD.'</span></samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="kwd">import</span><span class="pln"> re</span></kbd>                               <span class="u">④</span></a>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="kwd">sub</span><span class="pun">(</span><span class="str">'ROAD$'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'RD.'</span><span class="pun">,</span><span class="pln"> s</span><span class="pun">)</span></kbd>               <span class="u">⑤</span></a>
<samp class="pp"><span class="str">'100 NORTH BROAD RD.'</span></samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">My goal is to standardize a street address so that <code>'ROAD'</code> is always abbreviated as <code>'RD.'</code>. At first glance, I thought this was simple enough that I could just use the string method <code>replace()</code>. After all, all the data was already uppercase, so case mismatches would not be a problem. And the search string, <code>'ROAD'</code>, was a constant. And in this deceptively simple example, <code>s.replace()</code> does indeed work.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">Life, unfortunately, is full of counterexamples, and I quickly discovered this one. The problem here is that <code>'ROAD'</code> appears twice in the address, once as part of the street name <code>'BROAD'</code> and once as its own word. The <code>replace()</code> method sees these two occurrences and blindly replaces both of them; meanwhile, I see my addresses getting destroyed.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">To solve the problem of addresses with more than one <code>'ROAD'</code> substring, you could resort to something like this: only search and replace <code>'ROAD'</code> in the last four characters of the address (<code>s[-4:]</code>), and leave the string alone (<code>s[:-4]</code>).
 But you can see that this is already getting unwieldy. For example, the
 pattern is dependent on the length of the string you’re replacing. (If 
you were replacing <code>'STREET'</code> with <code>'ST.'</code>, you would need to use <code>s[:-6]</code> and <code>s[-6:].replace(...)</code>.) Would you like to come back in six months and debug this?  I know I wouldn’t.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">It’s time to move up to regular expressions. In Python, all functionality related to regular expressions is contained in the <code>re</code> module.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">⑤</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">Take a look at the first parameter: <code>'ROAD$'</code>. This is a simple regular expression that matches <code>'ROAD'</code> only when it occurs at the end of a string. The <code>$</code> means “end of the string.” (There is a corresponding character, the caret <code>^</code>, which means “beginning of the string.”) Using the <code>re.sub()</code> function, you search the string <var>s</var> for the regular expression <code>'ROAD$'</code> and replace it with <code>'RD.'</code>. This matches the <code>ROAD</code> at the end of the string <var>s</var>, but does <em>not</em> match the <code>ROAD</code> that’s part of the word <code>BROAD</code>, because that’s in the middle of <var>s</var>.
</td></tr></tbody></table>
<aside>^ matches the start of a string. $ matches the end of a string.</aside>
<p>Continuing with my story of scrubbing addresses, I soon discovered that the previous example, matching <code>'ROAD'</code>
 at the end of the address, was not good enough, because not all 
addresses included a street designation at all. Some addresses simply 
ended with the street name. I got away with it most of the time, but if 
the street name was <code>'BROAD'</code>, then the regular expression would match <code>'ROAD'</code> at the end of the string as part of the word <code>'BROAD'</code>, which is not what I wanted.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre1">skip over this code listing</a></p><pre id="autopre1" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre1')">hide</a>] [<a href="javascript:plainTextOnClick('autopre1')">open in new window</a>]</div><div class="b"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">s </span><span class="pun">=</span><span class="pln"> </span><span class="str">'100 BROAD'</span></kbd>
<samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="kwd">sub</span><span class="pun">(</span><span class="str">'ROAD$'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'RD.'</span><span class="pun">,</span><span class="pln"> s</span><span class="pun">)</span></kbd>
<samp class="pp"><span class="str">'100 BRD.'</span></samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="kwd">sub</span><span class="pun">(</span><span class="str">'\\bROAD$'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'RD.'</span><span class="pun">,</span><span class="pln"> s</span><span class="pun">)</span></kbd>   <span class="u">①</span></a>
<samp class="pp"><span class="str">'100 BROAD'</span></samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="kwd">sub</span><span class="pun">(</span><span class="pln">r</span><span class="str">'\bROAD$'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'RD.'</span><span class="pun">,</span><span class="pln"> s</span><span class="pun">)</span></kbd>   <span class="u">②</span></a>
<samp class="pp"><span class="str">'100 BROAD'</span></samp>
<samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">s </span><span class="pun">=</span><span class="pln"> </span><span class="str">'100 BROAD ROAD APT. 3'</span></kbd>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="kwd">sub</span><span class="pun">(</span><span class="pln">r</span><span class="str">'\bROAD$'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'RD.'</span><span class="pun">,</span><span class="pln"> s</span><span class="pun">)</span></kbd>   <span class="u">③</span></a>
<samp class="pp"><span class="str">'100 BROAD ROAD APT. 3'</span></samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="kwd">sub</span><span class="pun">(</span><span class="pln">r</span><span class="str">'\bROAD\b'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'RD.'</span><span class="pun">,</span><span class="pln"> s</span><span class="pun">)</span></kbd>  <span class="u">④</span></a>
<samp class="pp"><span class="str">'100 BROAD RD. APT 3'</span></samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">What I <em>really</em> wanted was to match <code>'ROAD'</code> when it was at the end of the string <em>and</em> it was its own word (and not a part of some larger word). To express this in a regular expression, you use <code>\b</code>, which means “a word boundary must occur right here.” In Python, this is complicated by the fact that the <code>'\'</code>
 character in a string must itself be escaped. This is sometimes 
referred to as the backslash plague, and it is one reason why regular 
expressions are easier in Perl than in Python. On the down side, Perl 
mixes regular expressions with other syntax, so if you have a bug, it 
may be hard to tell whether it’s a bug in syntax or a bug in your 
regular expression.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">To work around the backslash plague, you can use what is called a <i>raw string</i>, by prefixing the string with the letter <code>r</code>. This tells Python that nothing in this string should be escaped; <code>'\t'</code> is a tab character, but <code>r'\t'</code> is really the backslash character <code>\</code> followed by the letter <code>t</code>.
 I recommend always using raw strings when dealing with regular 
expressions; otherwise, things get too confusing too quickly (and 
regular expressions are confusing enough already).
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0"><em>*sigh*</em>  Unfortunately, I soon found more cases that contradicted my logic. In this case, the street address contained the word <code>'ROAD'</code>
 as a whole word by itself, but it wasn’t at the end, because the 
address had an apartment number after the street designation. Because <code>'ROAD'</code> isn’t at the very end of the string, it doesn’t match, so the entire call to <code>re.sub()</code> ends up replacing nothing at all, and you get the original string back, which is not what you want.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">To solve this problem, I removed the <code>$</code> character and added another <code>\b</code>. Now the regular expression reads “match <code>'ROAD'</code> when it’s a whole word by itself anywhere in the string,” whether at the end, the beginning, or somewhere in the middle.
</td></tr></tbody></table>
<p class="a">⁂

</p><h2 id="romannumerals">Case Study: Roman Numerals<a href="#romannumerals" class="hl">#</a></h2>
<p>You’ve most likely seen Roman numerals, even if you didn’t recognize 
them. You may have seen them in copyrights of old movies and television 
shows (“Copyright <code>MCMXLVI</code>” instead of “Copyright <code>1946</code>”), or on the dedication walls of libraries or universities (“established <code>MDCCCLXXXVIII</code>” instead of “established <code>1888</code>”).
 You may also have seen them in outlines and bibliographical references.
 It’s a system of representing numbers that really does date back to the
 ancient Roman empire (hence the name).
</p><p>In Roman numerals, there are seven characters that are repeated and combined in various ways to represent numbers.
</p><ul>
<li><code>I = 1</code>
</li><li><code>V = 5</code>
</li><li><code>X = 10</code>
</li><li><code>L = 50</code>
</li><li><code>C = 100</code>
</li><li><code>D = 500</code>
</li><li><code>M = 1000</code>
</li></ul>
<p>The following are some general rules for constructing Roman numerals:
</p><ul>
<li>Sometimes characters are additive. <code>I</code> is <code>1</code>, <code>II</code> is <code>2</code>, and <code>III</code> is <code>3</code>. <code>VI</code> is <code>6</code> (literally, “<code>5</code> and <code>1</code>”), <code>VII</code> is <code>7</code>, and <code>VIII</code> is <code>8</code>.
</li><li>The tens characters (<code>I</code>, <code>X</code>, <code>C</code>, and <code>M</code>) can be repeated up to three times. At <code>4</code>, you need to subtract from the next highest fives character. You can't represent <code>4</code> as <code>IIII</code>; instead, it is represented as <code>IV</code> (“<code>1</code> less than <code>5</code>”). <code>40</code> is written as <code>XL</code> (“<code>10</code> less than <code>50</code>”), <code>41</code> as <code>XLI</code>, <code>42</code> as <code>XLII</code>, <code>43</code> as <code>XLIII</code>, and then <code>44</code> as <code>XLIV</code> (“<code>10</code> less than <code>50</code>, then <code>1</code> less than <code>5</code>”).
</li><li>Sometimes characters are… the opposite of additive. By putting 
certain characters before others, you subtract from the final value. For
 example, at <code>9</code>, you need to subtract from the next highest tens character: <code>8</code> is <code>VIII</code>, but <code>9</code> is <code>IX</code> (“<code>1</code> less than <code>10</code>”), not <code>VIIII</code> (since the <code>I</code> character can not be repeated four times). <code>90</code> is <code>XC</code>, <code>900</code> is <code>CM</code>.
</li><li>The fives characters can not be repeated. <code>10</code> is always represented as <code>X</code>, never as <code>VV</code>. <code>100</code> is always <code>C</code>, never <code>LL</code>.
</li><li>Roman numerals are read left to right, so the order of characters matters very much. <code>DC</code> is <code>600</code>; <code>CD</code> is a completely different number (<code>400</code>, “<code>100</code> less than <code>500</code>”). <code>CI</code> is <code>101</code>; <code>IC</code> is not even a valid Roman numeral (because you can't subtract <code>1</code> directly from <code>100</code>; you would need to write it as <code>XCIX</code>, “<code>10</code> less than <code>100</code>, then <code>1</code> less than <code>10</code>”).
</li></ul>
<h3 id="thousands">Checking For Thousands<a href="#thousands" class="hl">#</a></h3>
<p>What would it take to validate that an arbitrary string is a valid 
Roman numeral?  Let’s take it one digit at a time. Since Roman numerals 
are always written highest to lowest, let’s start with the highest: the 
thousands place. For numbers 1000 and higher, the thousands are 
represented by a series of <code>M</code> characters.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre2">skip over this code listing</a></p><pre id="autopre2" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre2')">hide</a>] [<a href="javascript:plainTextOnClick('autopre2')">open in new window</a>]</div><div class="b"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="kwd">import</span><span class="pln"> re</span></kbd>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">pattern </span><span class="pun">=</span><span class="pln"> </span><span class="str">'^M?M?M?$'</span></kbd>        <span class="u">①</span></a>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'M'</span><span class="pun">)</span></kbd>     <span class="u">②</span></a>
<samp>&lt;_sre.SRE_Match object at 0106FB58&gt;</samp>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MM'</span><span class="pun">)</span></kbd>    <span class="u">③</span></a>
<samp>&lt;_sre.SRE_Match object at 0106C290&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MMM'</span><span class="pun">)</span></kbd>   <span class="u">④</span></a>
<samp>&lt;_sre.SRE_Match object at 0106AA38&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MMMM'</span><span class="pun">)</span></kbd>  <span class="u">⑤</span></a>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">)</span></kbd>      <span class="u">⑥</span></a>
<samp>&lt;_sre.SRE_Match object at 0106F4A8&gt;</samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">This pattern has three parts. <code>^</code>
 matches what follows only at the beginning of the string. If this were 
not specified, the pattern would match no matter where the <code>M</code> characters were, which is not what you want. You want to make sure that the <code>M</code> characters, if they’re there, are at the beginning of the string. <code>M?</code> optionally matches a single <code>M</code> character. Since this is repeated three times, you’re matching anywhere from zero to three <code>M</code> characters in a row. And <code>$</code> matches the end of the string. When combined with the <code>^</code>
 character at the beginning, this means that the pattern must match the 
entire string, with no other characters before or after the <code>M</code> characters.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">The essence of the <code>re</code> module is the <code>search()</code> function, that takes a regular expression (<var>pattern</var>) and a string (<code>'M'</code>) to try to match against the regular expression. If a match is found, <code>search()</code> returns an object which has various methods to describe the match; if no match is found, <code>search()</code> returns <code>None</code>,
 the Python null value. All you care about at the moment is whether the 
pattern matches, which you can tell by just looking at the return value 
of <code>search()</code>. <code>'M'</code> matches this regular expression, because the first optional <code>M</code> matches and the second and third optional <code>M</code> characters are ignored.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;"><code>'MM'</code> matches because the first and second optional <code>M</code> characters match and the third <code>M</code> is ignored.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0"><code>'MMM'</code> matches because all three <code>M</code> characters match.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">⑤</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0"><code>'MMMM'</code> does not match. All three <code>M</code> characters match, but then the regular expression insists on the string ending (because of the <code>$</code> character), and the string doesn’t end yet (because of the fourth <code>M</code>). So <code>search()</code> returns <code>None</code>.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">⑥</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">Interestingly, an empty string also matches this regular expression, since all the <code>M</code> characters are optional.
</td></tr></tbody></table>
<h3 id="hundreds">Checking For Hundreds<a href="#hundreds" class="hl">#</a></h3>
<aside>? makes a pattern optional.</aside>
<p>The hundreds place is more difficult than the thousands, because 
there are several mutually exclusive ways it could be expressed, 
depending on its value.
</p><ul>
<li><code>100 = C</code>
</li><li><code>200 = CC</code>
</li><li><code>300 = CCC</code>
</li><li><code>400 = CD</code>
</li><li><code>500 = D</code>
</li><li><code>600 = DC</code>
</li><li><code>700 = DCC</code>
</li><li><code>800 = DCCC</code>
</li><li><code>900 = CM</code>
</li></ul>
<p>So there are four possible patterns:
</p><ul>
<li><code>CM</code>
</li><li><code>CD</code>
</li><li>Zero to three <code>C</code> characters (zero if the hundreds place is 0)
</li><li><code>D</code>, followed by zero to three <code>C</code> characters
</li></ul>
<p>The last two patterns can be combined:
</p><ul>
<li>an optional <code>D</code>, followed by zero to three <code>C</code> characters
</li></ul>
<p>This example shows how to validate the hundreds place of a Roman numeral.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre3">skip over this code listing</a></p><pre id="autopre3" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre3')">hide</a>] [<a href="javascript:plainTextOnClick('autopre3')">open in new window</a>]</div><div class="b"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="kwd">import</span><span class="pln"> re</span></kbd>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">pattern </span><span class="pun">=</span><span class="pln"> </span><span class="str">'^M?M?M?(CM|CD|D?C?C?C?)$'</span></kbd>  <span class="u">①</span></a>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MCM'</span><span class="pun">)</span></kbd>             <span class="u">②</span></a>
<samp>&lt;_sre.SRE_Match object at 01070390&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MD'</span><span class="pun">)</span></kbd>              <span class="u">③</span></a>
<samp>&lt;_sre.SRE_Match object at 01073A50&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MMMCCC'</span><span class="pun">)</span></kbd>          <span class="u">④</span></a>
<samp>&lt;_sre.SRE_Match object at 010748A8&gt;</samp>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MCMC'</span><span class="pun">)</span></kbd>            <span class="u">⑤</span></a>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">)</span></kbd>                <span class="u">⑥</span></a>
<samp>&lt;_sre.SRE_Match object at 01071D98&gt;</samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This pattern starts out the same as the previous one, checking for the beginning of the string (<code>^</code>), then the thousands place (<code>M?M?M?</code>).
 Then it has the new part, in parentheses, which defines a set of three 
mutually exclusive patterns, separated by vertical bars: <code>CM</code>, <code>CD</code>, and <code>D?C?C?C?</code> (which is an optional <code>D</code> followed by zero to three optional <code>C</code>
 characters). The regular expression parser checks for each of these 
patterns in order (from left to right), takes the first one that 
matches, and ignores the rest.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0"><code>'MCM'</code> matches because the first <code>M</code> matches, the second and third <code>M</code> characters are ignored, and the <code>CM</code> matches (so the <code>CD</code> and <code>D?C?C?C?</code> patterns are never even considered). <code>MCM</code> is the Roman numeral representation of <code>1900</code>.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0"><code>'MD'</code> matches because the first <code>M</code> matches, the second and third <code>M</code> characters are ignored, and the <code>D?C?C?C?</code> pattern matches <code>D</code> (each of the three <code>C</code> characters are optional and are ignored). <code>MD</code> is the Roman numeral representation of <code>1500</code>.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0"><code>'MMMCCC'</code> matches because all three <code>M</code> characters match, and the <code>D?C?C?C?</code> pattern matches <code>CCC</code> (the <code>D</code> is optional and is ignored). <code>MMMCCC</code> is the Roman numeral representation of <code>3300</code>.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">⑤</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;"><code>'MCMC'</code> does not match. The first <code>M</code> matches, the second and third <code>M</code> characters are ignored, and the <code>CM</code> matches, but then the <code>$</code> does not match because you’re not at the end of the string yet (you still have an unmatched <code>C</code> character). The <code>C</code> does <em>not</em> match as part of the <code>D?C?C?C?</code> pattern, because the mutually exclusive <code>CM</code> pattern has already matched.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">⑥</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">Interestingly, an empty string still matches this pattern, because all the <code>M</code> characters are optional and ignored, and the empty string matches the <code>D?C?C?C?</code> pattern where all the characters are optional and ignored.
</td></tr></tbody></table>
<p>Whew! See how quickly regular expressions can get nasty?  And you’ve 
only covered the thousands and hundreds places of Roman numerals. But if
 you followed all that, the tens and ones places are easy, because 
they’re exactly the same pattern. But let’s look at another way to 
express the pattern.
</p><p class="a">⁂

</p><h2 id="nmsyntax">Using The <code>{n,m}</code> Syntax<a href="#nmsyntax" class="hl">#</a></h2>
<aside>{1,4} matches between 1 and 4 occurrences of a pattern.</aside>
<p>In the previous section, you were dealing with a pattern where the 
same character could be repeated up to three times. There is another way
 to express this in regular expressions, which some people find more 
readable. First look at the method we already used in the previous 
example.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre4">skip over this code listing</a></p><pre id="autopre4" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre4')">hide</a>] [<a href="javascript:plainTextOnClick('autopre4')">open in new window</a>]</div><div class="b"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="kwd">import</span><span class="pln"> re</span></kbd>
<samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">pattern </span><span class="pun">=</span><span class="pln"> </span><span class="str">'^M?M?M?$'</span></kbd>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'M'</span><span class="pun">)</span></kbd>     <span class="u">①</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MM'</span><span class="pun">)</span></kbd>    <span class="u">②</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48&gt;</samp>
<a style="background-color: inherit; cursor: inherit;"><samp>&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MMM'</span><span class="pun">)</span></kbd>   <span class="u">③</span></a>
<samp class="pp"><span class="pln">&lt;_sre.SRE_Match object at 0x008EE090&gt;</span></samp>
<a><samp>&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MMMM'</span><span class="pun">)</span></kbd>  <span class="u">④</span></a>
<samp class="p">&gt;&gt;&gt; </samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, and then the first optional <code>M</code>, but not the second and third <code>M</code> (but that’s okay because they’re optional), and then the end of the string.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, and then the first and second optional <code>M</code>, but not the third <code>M</code> (but that’s okay because it’s optional), and then the end of the string.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">This matches the start of the string, and then all three optional <code>M</code>, and then the end of the string.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, and then all three optional <code>M</code>, but then does not match the end of the string (because there is still one unmatched <code>M</code>), so the pattern does not match and returns <code>None</code>.
</td></tr></tbody></table>
<p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre5">skip over this code listing</a></p><pre id="autopre5" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre5')">hide</a>] [<a href="javascript:plainTextOnClick('autopre5')">open in new window</a>]</div><div class="b"><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">pattern </span><span class="pun">=</span><span class="pln"> </span><span class="str">'^M{0,3}$'</span></kbd>        <span class="u">①</span></a>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'M'</span><span class="pun">)</span></kbd>     <span class="u">②</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MM'</span><span class="pun">)</span></kbd>    <span class="u">③</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MMM'</span><span class="pun">)</span></kbd>   <span class="u">④</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEDA8&gt;</samp>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MMMM'</span><span class="pun">)</span></kbd>  <span class="u">⑤</span></a>
<samp>&gt;&gt;&gt; </samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This pattern says: “Match the start of the string, then anywhere from zero to three <code>M</code>
 characters, then the end of the string.”  The 0 and 3 can be any 
numbers; if you want to match at least one but no more than three <code>M</code> characters, you could say <code>M{1,3}</code>.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, then one <code>M</code> out of a possible three, then the end of the string.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, then two <code>M</code> out of a possible three, then the end of the string.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, then three <code>M</code> out of a possible three, then the end of the string.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">⑤</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">This matches the start of the string, then three <code>M</code> out of a possible three, but then <em>does not match</em> the end of the string. The regular expression allows for up to only three <code>M</code> characters before the end of the string, but you have four, so the pattern does not match and returns <code>None</code>.
</td></tr></tbody></table>
<h3 id="tensandones">Checking For Tens And Ones<a href="#tensandones" class="hl">#</a></h3>
<p>Now let’s expand the Roman numeral regular expression to cover the tens and ones place. This example shows the check for tens.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre6">skip over this code listing</a></p><pre id="autopre6" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre6')">hide</a>] [<a href="javascript:plainTextOnClick('autopre6')">open in new window</a>]</div><div class="b"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">pattern </span><span class="pun">=</span><span class="pln"> </span><span class="str">'^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)$'</span></kbd>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MCMXL'</span><span class="pun">)</span></kbd>     <span class="u">①</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MCML'</span><span class="pun">)</span></kbd>      <span class="u">②</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48&gt;</samp>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MCMLX'</span><span class="pun">)</span></kbd>     <span class="u">③</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MCMLXXX'</span><span class="pun">)</span></kbd>   <span class="u">④</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MCMLXXXX'</span><span class="pun">)</span></kbd>  <span class="u">⑤</span></a>
<samp class="p">&gt;&gt;&gt; </samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">This matches the start of the string, then the first optional <code>M</code>, then <code>CM</code>, then <code>XL</code>, then the end of the string. Remember, the <code>(A|B|C)</code> syntax means “match exactly one of A, B, or C”. You match <code>XL</code>, so you ignore the <code>XC</code> and <code>L?X?X?X?</code> choices, and then move on to the end of the string. <code>MCMXL</code> is the Roman numeral representation of <code>1940</code>.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, then the first optional <code>M</code>, then <code>CM</code>, then <code>L?X?X?X?</code>. Of the <code>L?X?X?X?</code>, it matches the <code>L</code> and skips all three optional <code>X</code> characters. Then you move to the end of the string. <code>MCML</code> is the Roman numeral representation of <code>1950</code>.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">This matches the start of the string, then the first optional <code>M</code>, then <code>CM</code>, then the optional <code>L</code> and the first optional <code>X</code>, skips the second and third optional <code>X</code>, then the end of the string. <code>MCMLX</code> is the Roman numeral representation of <code>1960</code>.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, then the first optional <code>M</code>, then <code>CM</code>, then the optional <code>L</code> and all three optional <code>X</code> characters, then the end of the string. <code>MCMLXXX</code> is the Roman numeral representation of <code>1980</code>.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">⑤</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, then the first optional <code>M</code>, then <code>CM</code>, then the optional <code>L</code> and all three optional <code>X</code> characters, then <em>fails to match</em> the end of the string because there is still one more <code>X</code> unaccounted for. So the entire pattern fails to match, and returns <code>None</code>. <code>MCMLXXXX</code> is not a valid Roman numeral.
</td></tr></tbody></table>
<aside>(A|B) matches either pattern A or pattern B, but not both.</aside>
<p>The expression for the ones place follows the same pattern. I’ll spare you the details and show you the end result.
</p><pre class="nd screen"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">pattern </span><span class="pun">=</span><span class="pln"> </span><span class="str">'^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$'</span></kbd>
</pre><p>So what does that look like using this alternate <code>{n,m}</code> syntax?  This example shows the new syntax.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre7">skip over this code listing</a></p><pre id="autopre7" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre7')">hide</a>] [<a href="javascript:plainTextOnClick('autopre7')">open in new window</a>]</div><div class="b"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">pattern </span><span class="pun">=</span><span class="pln"> </span><span class="str">'^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$'</span></kbd>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MDLV'</span><span class="pun">)</span></kbd>              <span class="u">①</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MMDCLXVI'</span><span class="pun">)</span></kbd>          <span class="u">②</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MMMDCCCLXXXVIII'</span><span class="pun">)</span></kbd>   <span class="u">③</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48&gt;</samp>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'I'</span><span class="pun">)</span></kbd>                 <span class="u">④</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48&gt;</samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, then one of a possible three <code>M</code> characters, then <code>D?C{0,3}</code>. Of that, it matches the optional <code>D</code> and zero of three possible <code>C</code> characters. Moving on, it matches <code>L?X{0,3}</code> by matching the optional <code>L</code> and zero of three possible <code>X</code> characters. Then it matches <code>V?I{0,3}</code> by matching the optional <code>V</code> and zero of three possible <code>I</code> characters, and finally the end of the string. <code>MDLV</code> is the Roman numeral representation of <code>1555</code>.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, then two of a possible three <code>M</code> characters, then the <code>D?C{0,3}</code> with a <code>D</code> and one of three possible <code>C</code> characters; then <code>L?X{0,3}</code> with an <code>L</code> and one of three possible <code>X</code> characters; then <code>V?I{0,3}</code> with a <code>V</code> and one of three possible <code>I</code> characters; then the end of the string. <code>MMDCLXVI</code> is the Roman numeral representation of <code>2666</code>.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, then three out of three <code>M</code> characters, then <code>D?C{0,3}</code> with a <code>D</code> and three out of three <code>C</code> characters; then <code>L?X{0,3}</code> with an <code>L</code> and three out of three <code>X</code> characters; then <code>V?I{0,3}</code> with a <code>V</code> and three out of three <code>I</code> characters; then the end of the string. <code>MMMDCCCLXXXVIII</code> is the Roman numeral representation of <code>3888</code>, and it’s the longest Roman numeral you can write without extended syntax.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">Watch
 closely. (I feel like a magician. “Watch closely, kids, I’m going to 
pull a rabbit out of my hat.”)  This matches the start of the string, 
then zero out of three <code>M</code>, then matches <code>D?C{0,3}</code> by skipping the optional <code>D</code> and matching zero out of three <code>C</code>, then matches <code>L?X{0,3}</code> by skipping the optional <code>L</code> and matching zero out of three <code>X</code>, then matches <code>V?I{0,3}</code> by skipping the optional <code>V</code> and matching one out of three <code>I</code>. Then the end of the string. Whoa.
</td></tr></tbody></table>
<p>If you followed all that and understood it on the first try, you’re 
doing better than I did. Now imagine trying to understand someone else’s
 regular expressions, in the middle of a critical function of a large 
program. Or even imagine coming back to your own regular expressions a 
few months later. I’ve done it, and it’s not a pretty sight.
</p><p>Now let’s explore an alternate syntax that can help keep your expressions maintainable.
</p><p class="a">⁂

</p><h2 id="verbosere">Verbose Regular Expressions<a href="#verbosere" class="hl">#</a></h2>
<p>So far you’ve just been dealing with what I’ll call “compact” regular
 expressions. As you’ve seen, they are difficult to read, and even if 
you figure out what one does, that’s no guarantee that you’ll be able to
 understand it six months later. What you really need is inline 
documentation.
</p><p>Python allows you to do this with something called <i>verbose regular expressions</i>. A verbose regular expression is different from a compact regular expression in two ways:
</p><ul>
<li>Whitespace is ignored. Spaces, tabs, and carriage returns are not 
matched as spaces, tabs, and carriage returns. They’re not matched at 
all. (If you want to match a space in a verbose regular expression, 
you’ll need to escape it by putting a backslash in front of it.)
</li><li>Comments are ignored. A comment in a verbose regular expression is just like a comment in Python code: it starts with a <code>#</code>
 character and goes until the end of the line. In this case it’s a 
comment within a multi-line string instead of within your source code, 
but it works the same way.
</li></ul>
<p>This will be more clear with an example. Let’s revisit the compact 
regular expression you’ve been working with, and make it a verbose 
regular expression. This example shows how.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre8">skip over this code listing</a></p><pre id="autopre8" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre8')">hide</a>] [<a href="javascript:plainTextOnClick('autopre8')">open in new window</a>]</div><div class="b"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">pattern </span><span class="pun">=</span><span class="pln"> </span><span class="str">'''<br>&nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # beginning of string<br>&nbsp; &nbsp; M{0,3} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# thousands - 0 to 3 Ms<br>&nbsp; &nbsp; (CM|CD|D?C{0,3}) &nbsp; &nbsp;# hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 Cs),<br>&nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or 500-800 (D, 
followed by 0 to 3 Cs)<br>&nbsp; &nbsp; (XC|XL|L?X{0,3}) &nbsp; &nbsp;# tens - 90 (XC), 40 (XL), 0-30 (0 to 3 Xs),<br>&nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; # &nbsp; &nbsp; &nbsp; &nbsp;or 50-80 (L, followed by 0 to 3 Xs)<br>&nbsp; &nbsp; (IX|IV|V?I{0,3}) &nbsp; &nbsp;# ones - 9 (IX), 4 (IV), 0-3 (0 to 3 Is),<br>&nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; # &nbsp; &nbsp; &nbsp; &nbsp;or 5-8 (V, followed by 0 to 3 Is)<br>&nbsp; &nbsp; $ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # end of string<br>&nbsp; &nbsp; '''</span></kbd>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'M'</span><span class="pun">,</span><span class="pln"> re</span><span class="pun">.</span><span class="pln">VERBOSE</span><span class="pun">)</span></kbd>                 <span class="u">①</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MCMLXXXIX'</span><span class="pun">,</span><span class="pln"> re</span><span class="pun">.</span><span class="pln">VERBOSE</span><span class="pun">)</span></kbd>         <span class="u">②</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'MMMDCCCLXXXVIII'</span><span class="pun">,</span><span class="pln"> re</span><span class="pun">.</span><span class="pln">VERBOSE</span><span class="pun">)</span></kbd>   <span class="u">③</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48&gt;</samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">re</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">,</span><span class="pln"> </span><span class="str">'M'</span><span class="pun">)</span></kbd>                             <span class="u">④</span></a></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">The
 most important thing to remember when using verbose regular expressions
 is that you need to pass an extra argument when working with them: <code>re.VERBOSE</code> is a constant defined in the <code>re</code>
 module that signals that the pattern should be treated as a verbose 
regular expression. As you can see, this pattern has quite a bit of 
whitespace (all of which is ignored), and several comments (all of which
 are ignored). Once you ignore the whitespace and the comments, this is 
exactly the same regular expression as you saw in the previous section, 
but it’s a lot more readable.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, then one of a possible three <code>M</code>, then <code>CM</code>, then <code>L</code> and three of a possible three <code>X</code>, then <code>IX</code>, then the end of the string.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This matches the start of the string, then three of a possible three <code>M</code>, then <code>D</code> and three of a possible three <code>C</code>, then <code>L</code> and three of a possible three <code>X</code>, then <code>V</code> and three of a possible three <code>I</code>, then the end of the string.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This does not match. Why?  Because it doesn’t have the <code>re.VERBOSE</code> flag, so the <code>re.search</code>
 function is treating the pattern as a compact regular expression, with 
significant whitespace and literal hash marks. Python can’t auto-detect 
whether a regular expression is verbose or not. Python assumes every 
regular expression is compact unless you explicitly state that it is 
verbose.
</td></tr></tbody></table>
<p class="a">⁂

</p><h2 id="phonenumbers">Case study: Parsing Phone Numbers<a href="#phonenumbers" class="hl">#</a></h2>
<aside>\d matches any numeric digit (0–9). \D matches anything but digits.</aside>
<p>So far you’ve concentrated on matching whole patterns. Either the 
pattern matches, or it doesn’t. But regular expressions are much more 
powerful than that. When a regular expression <em>does</em> match, you can pick out specific pieces of it. You can find out what matched where.
</p><p>This example came from another real-world problem I encountered, 
again from a previous day job. The problem: parsing an American phone 
number. The client wanted to be able to enter the number free-form (in a
 single field), but then wanted to store the area code, trunk, number, 
and optionally an extension separately in the company’s database. I 
scoured the Web and found many examples of regular expressions that 
purported to do this, but none of them were permissive enough.
</p><p>Here are the phone numbers I needed to be able to accept:
</p><ul>
<li><code>800-555-1212</code>
</li><li><code>800 555 1212</code>
</li><li><code>800.555.1212</code>
</li><li><code>(800) 555-1212</code>
</li><li><code>1-800-555-1212</code>
</li><li><code>800-555-1212-1234</code>
</li><li><code>800-555-1212x1234</code>
</li><li><code>800-555-1212 ext. 1234</code>
</li><li><code>work 1-(800) 555.1212 #1234</code>
</li></ul>
<p>Quite a variety! In each of these cases, I need to know that the area code was <code>800</code>, the trunk was <code>555</code>, and the rest of the phone number was <code>1212</code>. For those with an extension, I need to know that the extension was <code>1234</code>.
</p><p>Let’s work through developing a solution for phone number parsing. This example shows the first step.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre9">skip over this code listing</a></p><pre id="autopre9" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre9')">hide</a>] [<a href="javascript:plainTextOnClick('autopre9')">open in new window</a>]</div><div class="b"><a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern </span><span class="pun">=</span><span class="pln"> re</span><span class="pun">.</span><span class="pln">compile</span><span class="pun">(</span><span class="pln">r</span><span class="str">'^(\d{3})-(\d{3})-(\d{4})$'</span><span class="pun">)</span></kbd>  <span class="u">①</span></a>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800-555-1212'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>             <span class="u">②</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">)</span></samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800-555-1212-1234'</span><span class="pun">)</span></kbd>                 <span class="u">③</span></a>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800-555-1212-1234'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>        <span class="u">④</span></a>
<samp class="traceback">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'groups'</samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">Always read regular expressions from left to right. This one matches the beginning of the string, and then <code>(\d{3})</code>. What’s <code>\d{3}</code>?  Well, <code>\d</code> means “any numeric digit” (0 through <code>9</code>). The <code>{3}</code> means “match exactly three numeric digits”; it’s a variation on the <a href="#nmsyntax"><code>{n,m} syntax</code></a> you saw earlier. Putting it all in parentheses means “match exactly three numeric digits, <em>and then remember them as a group that I can ask for later</em>”.
 Then match a literal hyphen. Then match another group of exactly three 
digits. Then another literal hyphen. Then another group of exactly four 
digits. Then match the end of the string.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">To get access to the groups that the regular expression parser remembered along the way, use the <code>groups()</code> method on the object that the <code>search()</code>
 method returns. It will return a tuple of however many groups were 
defined in the regular expression. In this case, you defined three 
groups, one with three digits, one with three digits, and one with four 
digits.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This
 regular expression is not the final answer, because it doesn’t handle a
 phone number with an extension on the end. For that, you’ll need to 
expand the regular expression.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">And this is why you should never “chain” the <code>search()</code> and <code>groups()</code> methods in production code. If the <code>search()</code> method returns no matches, it returns <a href="http://www.diveintopython3.net/native-datatypes.html#none"><code>None</code></a>, not a regular expression match object. Calling <code>None.groups()</code> raises a perfectly obvious exception: <code>None</code> doesn’t have a <code>groups()</code>
 method. (Of course, it’s slightly less obvious when you get this 
exception from deep within your code. Yes, I speak from experience 
here.)
</td></tr></tbody></table>
<p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre10">skip over this code listing</a></p><pre id="autopre10" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre10')">hide</a>] [<a href="javascript:plainTextOnClick('autopre10')">open in new window</a>]</div><div class="b"><a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern </span><span class="pun">=</span><span class="pln"> re</span><span class="pun">.</span><span class="pln">compile</span><span class="pun">(</span><span class="pln">r</span><span class="str">'^(\d{3})-(\d{3})-(\d{4})-(\d+)$'</span><span class="pun">)</span></kbd>  <span class="u">①</span></a>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800-555-1212-1234'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>              <span class="u">②</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1234'</span><span class="pun">)</span></samp>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800 555 1212 1234'</span><span class="pun">)</span></kbd>                       <span class="u">③</span></a>
<samp class="p">&gt;&gt;&gt; </samp>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800-555-1212'</span><span class="pun">)</span></kbd>                            <span class="u">④</span></a>
<samp class="p">&gt;&gt;&gt; </samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">This
 regular expression is almost identical to the previous one. Just as 
before, you match the beginning of the string, then a remembered group 
of three digits, then a hyphen, then a remembered group of three digits,
 then a hyphen, then a remembered group of four digits. What’s new is 
that you then match another hyphen, and a remembered group of one or 
more digits, then the end of the string.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">The <code>groups()</code> method now returns a tuple of four elements, since the regular expression now defines four groups to remember.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">Unfortunately,
 this regular expression is not the final answer either, because it 
assumes that the different parts of the phone number are separated by 
hyphens. What if they’re separated by spaces, or commas, or dots?  You 
need a more general solution to match several different types of 
separators.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">Oops!
 Not only does this regular expression not do everything you want, it’s 
actually a step backwards, because now you can’t parse phone numbers <em>without</em>
 an extension. That’s not what you wanted at all; if the extension is 
there, you want to know what it is, but if it’s not there, you still 
want to know what the different parts of the main number are.
</td></tr></tbody></table>
<p>The next example shows the regular expression to handle separators between the different parts of the phone number.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre11">skip over this code listing</a></p><pre id="autopre11" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre11')">hide</a>] [<a href="javascript:plainTextOnClick('autopre11')">open in new window</a>]</div><div class="b"><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern </span><span class="pun">=</span><span class="pln"> re</span><span class="pun">.</span><span class="pln">compile</span><span class="pun">(</span><span class="pln">r</span><span class="str">'^(\d{3})\D+(\d{3})\D+(\d{4})\D+(\d+)$'</span><span class="pun">)</span></kbd>  <span class="u">①</span></a>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800 555 1212 1234'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>  <span class="u">②</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1234'</span><span class="pun">)</span></samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800-555-1212-1234'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>  <span class="u">③</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1234'</span><span class="pun">)</span></samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'80055512121234'</span><span class="pun">)</span></kbd>              <span class="u">④</span></a>
<samp class="p">&gt;&gt;&gt; </samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800-555-1212'</span><span class="pun">)</span></kbd>                <span class="u">⑤</span></a>
<samp class="p">&gt;&gt;&gt; </samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">Hang on to your hat. You’re matching the beginning of the string, then a group of three digits, then <code>\D+</code>. What the heck is that?  Well, <code>\D</code> matches any character <em>except</em> a numeric digit, and <code>+</code> means “1 or more”. So <code>\D+</code>
 matches one or more characters that are not digits. This is what you’re
 using instead of a literal hyphen, to try to match different 
separators.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">Using <code>\D+</code> instead of <code>-</code> means you can now match phone numbers where the parts are separated by spaces instead of hyphens.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">Of course, phone numbers separated by hyphens still work too.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">Unfortunately,
 this is still not the final answer, because it assumes that there is a 
separator at all. What if the phone number is entered without any spaces
 or hyphens at all?
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">⑤</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">Oops!
 This still hasn’t fixed the problem of requiring extensions. Now you 
have two problems, but you can solve both of them with the same 
technique.
</td></tr></tbody></table>
<p>The next example shows the regular expression for handling phone numbers <em>without</em> separators.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre12">skip over this code listing</a></p><pre id="autopre12" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre12')">hide</a>] [<a href="javascript:plainTextOnClick('autopre12')">open in new window</a>]</div><div class="b"><a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern </span><span class="pun">=</span><span class="pln"> re</span><span class="pun">.</span><span class="pln">compile</span><span class="pun">(</span><span class="pln">r</span><span class="str">'^(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$'</span><span class="pun">)</span></kbd>  <span class="u">①</span></a>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'80055512121234'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>      <span class="u">②</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1234'</span><span class="pun">)</span></samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800.555.1212 x1234'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>  <span class="u">③</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1234'</span><span class="pun">)</span></samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800-555-1212'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>        <span class="u">④</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">)</span></samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'(800)5551212 x1234'</span><span class="pun">)</span></kbd>           <span class="u">⑤</span></a>
<samp class="p">&gt;&gt;&gt; </samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">The only change you’ve made since that last step is changing all the <code>+</code> to <code>*</code>. Instead of <code>\D+</code> between the parts of the phone number, you now match on <code>\D*</code>. Remember that <code>+</code> means “1 or more”?  Well, <code>*</code> means “zero or more”. So now you should be able to parse phone numbers even when there is no separator character at all.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">Lo and behold, it actually works. Why?  You matched the beginning of the string, then a remembered group of three digits (<code>800</code>), then zero non-numeric characters, then a remembered group of three digits (<code>555</code>), then zero non-numeric characters, then a remembered group of four digits (<code>1212</code>), then zero non-numeric characters, then a remembered group of an arbitrary number of digits (<code>1234</code>), then the end of the string.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">Other variations work now too: dots instead of hyphens, and both a space and an <code>x</code> before the extension.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">Finally, you’ve solved the other long-standing problem: extensions are optional again. If no extension is found, the <code>groups()</code> method still returns a tuple of four elements, but the fourth element is just an empty string.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">⑤</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">I
 hate to be the bearer of bad news, but you’re not finished yet. What’s 
the problem here?  There’s an extra character before the area code, but 
the regular expression assumes that the area code is the first thing at 
the beginning of the string. No problem, you can use the same technique 
of “zero or more non-numeric characters” to skip over the leading 
characters before the area code.
</td></tr></tbody></table>
<p>The next example shows how to handle leading characters in phone numbers.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre13">skip over this code listing</a></p><pre id="autopre13" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre13')">hide</a>] [<a href="javascript:plainTextOnClick('autopre13')">open in new window</a>]</div><div class="b"><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern </span><span class="pun">=</span><span class="pln"> re</span><span class="pun">.</span><span class="pln">compile</span><span class="pun">(</span><span class="pln">r</span><span class="str">'^\D*(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$'</span><span class="pun">)</span></kbd>  <span class="u">①</span></a>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'(800)5551212 ext. 1234'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>                  <span class="u">②</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1234'</span><span class="pun">)</span></samp>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800-555-1212'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>                            <span class="u">③</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">)</span></samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'work 1-(800) 555.1212 #1234'</span><span class="pun">)</span></kbd>                      <span class="u">④</span></a>
<samp class="p">&gt;&gt;&gt; </samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This is the same as in the previous example, except now you’re matching <code>\D*</code>,
 zero or more non-numeric characters, before the first remembered group 
(the area code). Notice that you’re not remembering these non-numeric 
characters (they’re not in parentheses). If you find them, you’ll just 
skip over them and then start remembering the area code whenever you get
 to it.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">You
 can successfully parse the phone number, even with the leading left 
parenthesis before the area code. (The right parenthesis after the area 
code is already handled; it’s treated as a non-numeric separator and 
matched by the <code>\D*</code> after the first remembered group.)
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">Just
 a sanity check to make sure you haven’t broken anything that used to 
work. Since the leading characters are entirely optional, this matches 
the beginning of the string, then zero non-numeric characters, then a 
remembered group of three digits (<code>800</code>), then one non-numeric character (the hyphen), then a remembered group of three digits (<code>555</code>), then one non-numeric character (the hyphen), then a remembered group of four digits (<code>1212</code>), then zero non-numeric characters, then a remembered group of zero digits, then the end of the string.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">This
 is where regular expressions make me want to gouge my eyes out with a 
blunt object. Why doesn’t this phone number match? Because there’s a <code>1</code> before the area code, but you assumed that all the leading characters before the area code were non-numeric characters (<code>\D*</code>). Aargh.
</td></tr></tbody></table>
<p>Let’s back up for a second. So far the regular expressions have all 
matched from the beginning of the string. But now you see that there may
 be an indeterminate amount of stuff at the beginning of the string that
 you want to ignore. Rather than trying to match it all just so you can 
skip over it, let’s take a different approach: don’t explicitly match 
the beginning of the string at all. This approach is shown in the next 
example.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre14">skip over this code listing</a></p><pre id="autopre14" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre14')">hide</a>] [<a href="javascript:plainTextOnClick('autopre14')">open in new window</a>]</div><div class="b"><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern </span><span class="pun">=</span><span class="pln"> re</span><span class="pun">.</span><span class="pln">compile</span><span class="pun">(</span><span class="pln">r</span><span class="str">'(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$'</span><span class="pun">)</span></kbd>  <span class="u">①</span></a>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'work 1-(800) 555.1212 #1234'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>         <span class="u">②</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1234'</span><span class="pun">)</span></samp>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800-555-1212'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>                        <span class="u">③</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">)</span></samp>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'80055512121234'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>                      <span class="u">④</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1234'</span><span class="pun">)</span></samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">Note the lack of <code>^</code>
 in this regular expression. You are not matching the beginning of the 
string anymore. There’s nothing that says you need to match the entire 
input with your regular expression. The regular expression engine will 
do the hard work of figuring out where the input string starts to match,
 and go from there.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">Now
 you can successfully parse a phone number that includes leading 
characters and a leading digit, plus any number of any kind of 
separators around each part of the phone number.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">③</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">Sanity check. This still works.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">④</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">That still works too.
</td></tr></tbody></table>
<p>See how quickly a regular expression can get out of control?  Take a 
quick glance at any of the previous iterations. Can you tell the 
difference between one and the next?
</p><p>While you still understand the final answer (and it is the final 
answer; if you’ve discovered a case it doesn’t handle, I don’t want to 
know about it), let’s write it out as a verbose regular expression, 
before you forget why you made the choices you made.
</p><p class="skip"><a style="position: absolute; left: 0px; top: -500px; width: 1px; height: 1px; overflow: hidden;" href="#postautopre15">skip over this code listing</a></p><pre id="autopre15" class="screen"><div class="w">[<a class="toggle" href="javascript:toggleCodeBlock('autopre15')">hide</a>] [<a href="javascript:plainTextOnClick('autopre15')">open in new window</a>]</div><div class="b"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern </span><span class="pun">=</span><span class="pln"> re</span><span class="pun">.</span><span class="pln">compile</span><span class="pun">(</span><span class="pln">r</span><span class="str">'''<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # don'</span><span class="pln">t match beginning of </span><span class="kwd">string</span><span class="pun">,</span><span class="pln"> number can start anywhere<br>&nbsp; &nbsp; </span><span class="pun">(\</span><span class="pln">d</span><span class="pun">{</span><span class="lit">3</span><span class="pun">})</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># area code is 3 digits (e.g. '800')</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">\</span><span class="pln">D</span><span class="pun">*</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># optional separator is any number of non-digits</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">(\</span><span class="pln">d</span><span class="pun">{</span><span class="lit">3</span><span class="pun">})</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># trunk is 3 digits (e.g. '555')</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">\</span><span class="pln">D</span><span class="pun">*</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># optional separator</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">(\</span><span class="pln">d</span><span class="pun">{</span><span class="lit">4</span><span class="pun">})</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># rest of number is 4 digits (e.g. '1212')</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">\</span><span class="pln">D</span><span class="pun">*</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># optional separator</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">(\</span><span class="pln">d</span><span class="pun">*)</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># extension is optional and can be any number of digits</span><span class="pln"><br>&nbsp; &nbsp; $ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># end of string</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">''', re.VERBOSE)</span></kbd>
<a style="background-color: inherit; cursor: inherit;"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'work 1-(800) 555.1212 #1234'</span><span class="pun">).</span><span class="pln">groups</span><span class="pun">()</span></kbd>  <span class="u">①</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1234'</span><span class="pun">)</span></samp>
<a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp"><span class="pln">phonePattern</span><span class="pun">.</span><span class="pln">search</span><span class="pun">(</span><span class="str">'800-555-1212'</span><span class="pun">)</span></kbd>                          <span class="u">②</span></a>
<samp class="pp"><span class="pun">(</span><span class="str">'800'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'555'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'1212'</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">)</span></samp></div></pre>
<table style="width:100%;border-collapse:collapse;margin:0;border:0"><tbody><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">①</span></td><td style="vertical-align: top; margin: 0px; padding: 0px; width: auto; border: 0px none; background-color: inherit; cursor: inherit;">Other
 than being spread out over multiple lines, this is exactly the same 
regular expression as the last step, so it’s no surprise that it parses 
the same inputs.
</td></tr><tr><td style="text-align:center;vertical-align:baseline;margin:0;padding:0;width:2em;border:0"><span class="u">②</span></td><td style="vertical-align:top;margin:0;padding:0;width:auto;border:0">Final sanity check. Yes, this still works. You’re done.
</td></tr></tbody></table>
<p class="a">⁂

</p><h2 id="summary">Summary<a href="#summary" class="hl">#</a></h2>
<p>This is just the tiniest tip of the iceberg of what regular 
expressions can do. In other words, even though you’re completely 
overwhelmed by them now, believe me, you ain’t seen nothing yet.
</p><p>You should now be familiar with the following techniques:
</p><ul>
<li><code>^</code> matches the beginning of a string.
</li><li><code>$</code> matches the end of a string.
</li><li><code>\b</code> matches a word boundary.
</li><li><code>\d</code> matches any numeric digit.
</li><li><code>\D</code> matches any non-numeric character.
</li><li><code>x?</code> matches an optional <code>x</code> character (in other words, it matches an <code>x</code> zero or one times).
</li><li><code>x*</code> matches <code>x</code> zero or more times.
</li><li><code>x+</code> matches <code>x</code> one or more times.
</li><li><code>x{n,m}</code> matches an <code>x</code> character at least <code>n</code> times, but not more than <code>m</code> times.
</li><li><code>(a|b|c)</code> matches exactly one of <code>a</code>, <code>b</code> or <code>c</code>.
</li><li><code>(x)</code> in general is a <em>remembered group</em>. You can get the value of what matched by using the <code>groups()</code> method of the object returned by <code>re.search</code>.
</li></ul>
<p>Regular expressions are extremely powerful, but they are not the 
correct solution for every problem. You should learn enough about them 
to know when they are appropriate, when they will solve your problems, 
and when they will cause more problems than they solve.
</p><p class="v"><a href="http://www.diveintopython3.net/strings.html" rel="prev" title="back to “Strings”"><span class="u">☜</span></a> <a href="http://www.diveintopython3.net/generators.html" rel="next" title="onward to “Closures &amp; Generators”"><span class="u">☞</span></a>
</p><p class="c">© 2001–11 <a href="http://www.diveintopython3.net/about.html">Mark Pilgrim</a>
<script src="Regular%20expressions%20-%20Dive%20Into%20Python%203_files/jquery.js"></script>
<script src="Regular%20expressions%20-%20Dive%20Into%20Python%203_files/prettify.js"></script>
<script src="Regular%20expressions%20-%20Dive%20Into%20Python%203_files/dip3.js"></script>
</p></body></html>